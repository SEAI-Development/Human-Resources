"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouteFactory = void 0;
const instancefactory_1 = require("../instancefactory");
const noomierror_1 = require("../../tools/noomierror");
const util_1 = require("../../tools/util");
const application_1 = require("../../tools/application");
const routetypes_1 = require("../../types/routetypes");
/**
 * 路由工厂类
 * @remarks
 * 管理所有路由对象，进行路由处理
 */
class RouteFactory {
    /**
     * 注册路由
     * @param cfg -   路由配置
     */
    static registRoute(cfg) {
        if (!instancefactory_1.InstanceFactory.hasClass(cfg.clazz)) {
            instancefactory_1.InstanceFactory.addInstance(cfg.clazz, false);
        }
        if (!this.registRouteMap.has(cfg.clazz)) {
            this.registRouteMap.set(cfg.clazz, {
                paths: []
            });
        }
        const obj = this.registRouteMap.get(cfg.clazz);
        // 保存namespace
        obj.namespace = cfg.namespace;
        //只针对通配符进行处理
        if (cfg.path.indexOf('*') !== -1) {
            const reg = util_1.Util.toReg(cfg.path, 3);
            for (const o of Object.getOwnPropertyNames(cfg.clazz.prototype)) {
                //构造器，非方法，已注册的方法 不再处理
                if (o === 'constructor' ||
                    typeof cfg.clazz.prototype[o] !== 'function' ||
                    obj.paths.find(item => item.method === o)) {
                    continue;
                }
                if (reg.test(o)) {
                    obj.paths.push({ path: o, method: o });
                }
            }
        }
        else { //route装饰器
            obj.paths.push({ path: cfg.path, method: cfg.method.trim(), results: cfg.results });
        }
    }
    /**
     * 处理注册的路由
     * @remarks
     * 把所有注册的路由添加到路由工厂
     */
    static handleRegistedRouters() {
        for (const r of this.registRouteMap) {
            if (!instancefactory_1.InstanceFactory.hasClass(r[0])) {
                instancefactory_1.InstanceFactory.addInstance(r[0], false);
            }
            const cfg = r[1];
            const ns = cfg.namespace || '';
            for (const p of cfg.paths) {
                this.addRoute(util_1.Util.getUrlPath([ns, p.path]), r[0], p.method, p.results);
            }
        }
        // 清空regist map
        this.registRouteMap.clear();
    }
    /**
     * 添加路由
     * @param path -          路由路径，支持通配符*，需要method支持
     * @param clazz -         对应类
     * @param methodName -    方法名
     * @param results -       路由处理结果集
     */
    static addRoute(path, clazz, methodName, results) {
        // 已存在则不再添加（因为通配符在非通配符后面）
        if (this.routeMap.has(path)) {
            return;
        }
        if (results && results.length > 0) {
            for (const r of results) {
                if ((r.type === routetypes_1.ERouteResultType.CHAIN || r.type === routetypes_1.ERouteResultType.REDIRECT)
                    && (!r.url || typeof r.url !== 'string' || (r.url = r.url.trim()) === '')) {
                    throw new noomierror_1.NoomiError("2101");
                }
            }
        }
        this.routeMap.set(path, {
            clazz: clazz,
            method: methodName,
            results: results
        });
    }
    /**
     * 根据路径获取路由对象
     * @param path -    url路径
     * @returns         路由对象
     */
    static getRoute(path) {
        let item;
        let method; // 方法名
        // 下查找非通配符map
        if (this.routeMap.has(path)) {
            item = this.routeMap.get(path);
            method = item.method;
        }
        // 找到匹配的则返回
        if (item && method) {
            const instance = instancefactory_1.InstanceFactory.getInstance(item.clazz);
            if (instance && typeof instance[method] === 'function') {
                return { instance: instance, method: method, results: item.results };
            }
        }
        return null;
    }
    /**
     * 路由方法执行
     * @param route -       路由
     * @param req -         request 对象
     * @param res -         response 对象
     * @param params -      调用参数对象
     * @returns             路由执行结果
     */
    static async handleRoute(route, req, res, params) {
        //绑定path, 没有必要
        if (!route.path && req) {
            route.path = req.url;
        }
        //设置request
        if (typeof route.instance.setRequest === 'function') {
            route.instance.setRequest(req);
        }
        //设置response
        if (typeof route.instance.setResponse === 'function') {
            route.instance.setResponse(res);
        }
        //初始化参数
        if (!params) {
            params = await req.init();
        }
        //设置model
        if (typeof route.instance.setModel === 'function') {
            route.instance.setModel(params || {}, route.method);
        }
        //实际调用方法
        const func = route.instance[route.method];
        if (typeof func !== 'function') {
            throw new noomierror_1.NoomiError("1010");
        }
        const re = await func.call(route.instance, params);
        if (re === routetypes_1.ERouteResultType.REDIRECT) {
            return re;
        }
        return await this.handleResult(route, re);
    }
    /**
     * 处理路由结果
     * @param route -   route对象
     * @param data -    路由对应方法的返回值
     * @returns         处理后的结果
     */
    static async handleResult(route, data) {
        const results = route.results;
        if (results && results.length > 0) {
            // 单个结果，不判断返回值
            if (results.length === 1) {
                return await this.handleOneResult(route, results[0], data);
            }
            else {
                let r;
                for (r of results) {
                    // result不带value，或找到返回值匹配，则处理
                    if (r.value === undefined || data && data == r.value) {
                        return await this.handleOneResult(route, r, data);
                    }
                }
            }
        }
        // 默认回写json
        return await this.handleOneResult(route, {}, data);
    }
    /**
     * 处理一个路由结果
     * @param route -       route对象
     * @param result -      route result
     * @param data -        路由执行结果
     * @returns             cache数据对象或0
     */
    static async handleOneResult(route, result, data) {
        let url;
        const instance = route.instance;
        const res = route.instance['response'];
        // 返回值
        let ret = 0;
        switch (result.type) {
            case routetypes_1.ERouteResultType.REDIRECT: // 重定向
                url = handleParamUrl(instance, result.url);
                const pa = [];
                // 参数属性
                if (result.params && Array.isArray(result.params) && result.params.length > 0) {
                    for (const pn of result.params) {
                        const v = getValue(instance, pn);
                        if (v !== undefined) {
                            pa.push(pn + '=' + v);
                        }
                    }
                }
                const pas = pa.join('&');
                if (pas !== '') {
                    if (url.indexOf('?') === -1) {
                        url += '?' + pas;
                    }
                    else {
                        url += '&' + pas;
                    }
                }
                return res.redirect(url);
            case routetypes_1.ERouteResultType.CHAIN: // 路由器链
                url = handleParamUrl(instance, result.url);
                const url1 = application_1.App.url.parse(url).pathname;
                const params = application_1.App.qs.parse(application_1.App.url.parse(url).query);
                // 参数处理
                if (result.params && Array.isArray(result.params) && result.params.length > 0) {
                    for (const pn of result.params) {
                        const v = getValue(instance, pn);
                        if (v !== undefined) {
                            params[pn] = v;
                        }
                    }
                }
                const route1 = this.getRoute(url1);
                if (route1 === null) {
                    throw new noomierror_1.NoomiError("2103", url1);
                }
                // 设置route path
                route1.path = url1;
                return await this.handleRoute(route1, route.instance['request'], res, params);
            case routetypes_1.ERouteResultType.NONE: // 什么都不做
                break;
            case routetypes_1.ERouteResultType.STREAM: // 文件流
                // 文件名
                const pn = result.params[0];
                if (pn) {
                    let fn = getValue(instance, pn);
                    if (fn) {
                        fn = util_1.Util.getAbsPath([fn]);
                        if (!application_1.App.fs.existsSync(fn)) {
                            throw new noomierror_1.NoomiError('0050');
                        }
                        res.writeFileToClient({
                            data: fn
                        });
                    }
                }
                break;
            default: // json
                let mimeType;
                // 处理json对象
                if (typeof data === 'object') {
                    // data = JSON.stringify(data);
                    mimeType = 'application/json';
                }
                else {
                    mimeType = 'text/plain';
                }
                ret = {
                    data: data,
                    mimeType: mimeType
                };
        }
        return ret;
        /**
         * 处理带参数的url，参数放在`{}`中
         * @param instance -  路由实例
         * @param url -       源url，以`${propName}`格式出现
         * @returns         处理后的url
         */
        function handleParamUrl(instance, url) {
            const reg = /\$\{.*?\}/g;
            let r;
            // 处理带参数url
            while ((r = reg.exec(url)) !== null) {
                const pn = r[0].substring(2, r[0].length - 1);
                url = url.replace(r[0], getValue(instance, pn));
            }
            return url;
        }
        /**
         * 获取属性值
         * @param instance -    实例
         * @param pn -          属性名
         * @returns             属性值
         */
        function getValue(instance, pn) {
            if (instance[pn] !== undefined) {
                return instance[pn];
            }
            else if (instance['model'] && instance['model'][pn] !== undefined) {
                return instance['model'][pn];
            }
        }
    }
}
exports.RouteFactory = RouteFactory;
/**
 * 路由集合
 * key: 路由路径
 */
RouteFactory.routeMap = new Map();
/**
 * 注册路由map
 * @remarks
 * 由于`@Route和@Router`的执行顺序问题，为避免路由重复添加，初始化结束后统一处理
 *
 * key: 类
 *
 * value: RouterClass配置
 */
RouteFactory.registRouteMap = new Map();
//# sourceMappingURL=routefactory.js.map