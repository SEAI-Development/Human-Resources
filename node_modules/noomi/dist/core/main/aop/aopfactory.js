"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AopFactory = void 0;
const instancefactory_1 = require("../instancefactory");
const aopproxy_1 = require("./aopproxy");
const aoppointcut_1 = require("./aoppointcut");
/**
 * Aop工厂
 * 用于管理所有切面、切点
 */
class AopFactory {
    /**
     * 注册切点
     * @param cfg -   pointcut配置
     */
    static registPointcut(cfg) {
        const pc = this.getRegistPointcut(cfg.clazz, cfg.id, true);
        if (cfg.expressions) {
            pc.expressions = pc.expressions.concat(cfg.expressions);
        }
    }
    /**
     * 注册advice
     * @param cfg -   advice配置
     */
    static registAdvice(cfg) {
        if (!this.registAspectMap.has(cfg.clazz)) {
            return;
        }
        const pc = this.registAspectMap.get(cfg.clazz)[cfg.pointcutId];
        if (!pc) {
            return;
        }
        delete cfg.clazz;
        pc.advices.push(cfg);
    }
    /**
     * 从registAspectMap中获取注册的pointcut配置
     * @param clazz -         切面类
     * @param pointcutId -    切点id
     * @param create -        如果不存在，是否创建，如果为true，则创建，默认false
     * @returns             pointcut配置项
     */
    static getRegistPointcut(clazz, pointcutId, create) {
        let pc;
        if (this.registAspectMap.has(clazz)) {
            const obj = this.registAspectMap.get(clazz);
            pc = obj[pointcutId];
        }
        else {
            this.registAspectMap.set(clazz, {});
        }
        if (!pc && create) { // 新建pointcut配置项
            const obj = this.registAspectMap.get(clazz);
            pc = {
                advices: [],
                expressions: []
            };
            obj[pointcutId] = pc;
        }
        return pc;
    }
    /**
     * 添加切面
     * @remarks
     *
     * @param clazz -   切面类
     */
    static addAspect(clazz) {
        const cfg = this.registAspectMap.get(clazz);
        //未得到pointcut，则不处理切面
        if (!cfg) {
            return;
        }
        if (!instancefactory_1.InstanceFactory.hasClass(clazz)) {
            instancefactory_1.InstanceFactory.addInstance(clazz);
        }
        Object.keys(cfg).forEach(item => {
            const o = cfg[item];
            // 新建pointcut
            const pc = new aoppointcut_1.AopPointcut(item, o.expressions, clazz);
            // 加入切点集
            this.pointcuts.set(clazz.name + '.' + item, pc);
            // 为切点添加advice
            o.advices.forEach(item1 => {
                // 添加advice
                pc.addAdvice(item1);
            });
        });
        // 删除已处理的class
        this.registAspectMap.delete(clazz);
    }
    /**
     * 为切点添加表达式
     * @param pointcutId -  切点id
     * @param expression -  表达式或数组
     */
    static addExpression(pointcutId, expression) {
        const pc = this.pointcuts.get(pointcutId);
        if (!pc) {
            return;
        }
        pc.addExpression(expression);
    }
    /**
     * 为所有aop匹配的方法设置代理
     */
    static proxyAll() {
        if (!this.pointcuts || this.pointcuts.size === 0) {
            return;
        }
        const insts = instancefactory_1.InstanceFactory.getFactory();
        for (const ins of insts) {
            this.proxyOne(ins[0]);
        }
    }
    /**
     * 为某个类设置代理
     * @param clazz - 类
     */
    static proxyOne(clazz) {
        if (!this.pointcuts || this.pointcuts.size === 0) {
            return;
        }
        // 遍历pointcut
        let pc;
        for (pc of this.pointcuts.values()) {
            let reg;
            // 遍历expression
            for (reg of pc.expressions) {
                Object.getOwnPropertyNames(clazz.prototype).forEach(key => {
                    // 给方法设置代理，constructor 不需要代理
                    if (key === 'constructor' || typeof clazz.prototype[key] !== 'function') {
                        return;
                    }
                    // 添加到proxy method map
                    const name = clazz.name + '.' + key;
                    if (reg.test(name)) {
                        if (!this.proxyMethodMap.has(name)) {
                            this.proxyMethodMap.set(name, [pc]);
                            // 代理类方法
                            clazz.prototype[key] = aopproxy_1.AopProxy.invoke(clazz, key);
                        }
                        else {
                            this.proxyMethodMap.get(name).push(pc);
                        }
                    }
                });
            }
        }
    }
    /**
     * 根据id获取切点
     * @param pointcutId -    切点id
     * @returns             切点对象
     */
    static getPointcutById(pointcutId) {
        return this.pointcuts.get(pointcutId);
    }
    /**
     * 获取某个方法对应的advices
     * @param clazz -       类
     * @param methodName -  方法名
     * @returns             advice集合
     */
    static getAdvices(clazz, methodName) {
        const pointcuts = this.proxyMethodMap.get(clazz.name + '.' + methodName);
        if (pointcuts.length === 0) {
            return null;
        }
        let beforeArr = [];
        const aroundArr1 = []; // 前置around
        const aroundArr2 = []; // 后置around
        let afterArr = [];
        const throwArr = [];
        const returnArr = [];
        let pointcut;
        for (pointcut of pointcuts) {
            pointcut.advices.forEach(item => {
                const ins = instancefactory_1.InstanceFactory.getInstance(pointcut.aspectClazz);
                switch (item.type) {
                    case 'before':
                        beforeArr.push({
                            instance: ins,
                            method: item.method
                        });
                        return;
                    case 'after':
                        afterArr.push({
                            instance: ins,
                            method: item.method
                        });
                        return;
                    case 'around':
                        aroundArr1.push({
                            instance: ins,
                            method: item.method
                        });
                        aroundArr2.push({
                            instance: ins,
                            method: item.method
                        });
                        return;
                    case 'after-return':
                        returnArr.push({
                            instance: ins,
                            method: item.method
                        });
                        return;
                    case 'after-throw':
                        throwArr.push({
                            instance: ins,
                            method: item.method
                        });
                }
            });
        }
        beforeArr = aroundArr1.concat(beforeArr);
        afterArr = afterArr.concat(aroundArr2);
        return {
            before: beforeArr,
            after: afterArr,
            throws: throwArr,
            returns: returnArr
        };
    }
}
exports.AopFactory = AopFactory;
/**
 * 切点map
 * @remarks
 * 用于存储所有切点
 *
 * key:className.pointcutName
 *
 * value: pointcut
 */
AopFactory.pointcuts = new Map();
/**
 * 已代理方法map
 * key: instanctName.methodName
 * value: 切点集合
 */
AopFactory.proxyMethodMap = new Map();
/**
 * 注册切面map
 * @remarks
 * key:class
 *
 * value:object
 * ```json
 *  {
 *      isAspect:true,  // 避免用了pointcut，但是未使用Aspect注解
 *      pointCutId1:{
 *          expressions:Array<string>,
 *          advices:{type:类型,method:方法名}
 *      },
 *      ...
 *   }
 * ```
 */
AopFactory.registAspectMap = new Map();
//# sourceMappingURL=aopfactory.js.map